# - Load the data

data_mps <- readRDS("data/data_prompting_the_machine.rds")

# - Vector of models you want to prompt. The script will loop through each model
# - and prompt it with the same message. It will also create a new column for
# - each model in the dataframe to store the subject_content generated by the
# - model.

models <- c("gpt-3.5-turbo", "gpt-4", "gpt-4-0125-preview") 

# - Define the subject of the prompt (e.g., ideology, policies, etc.)
# - This is important for extracting the relevant content from the model output.
# - It should match the expected output format (e.g., JSON key) to extract the
# - relevant content from the model output.

prompt_subject <- "characteristics"

# - Save every 100 iterations you can modify it to your needs

save_interval <- 100 

# - The number of columns needed to store the output of the model. This is
# - important to know in advance to create the necessary columns in the 
# - dataframe. In this case, we are expecting 10 subject_content from the model 
# - which will be stored in 10 different columns.

column_needed <- 10

# - The number of trials to attempt before giving up. This is useful to avoid
# - getting stuck in an infinite loop if the model is not able to generate the
# - expected output. In this case, we will try up to 10 times before giving up.

number_of_trials <- 10

for (model_name in models) {

# - Convert model names to snake case for variable naming
# - Dynamically create column names based on the snake case model name
  
  # - Replace non-alphanumeric characters with underscores

  model_name_snake_case <- gsub("[^a-zA-Z0-9]", "_", model_name)  

  prompt_cols <- paste0(model_name_snake_case, "_", prompt_subject, 1:column_needed)
  data_mps[prompt_cols] <- NA  # Initialize new columns for this model

  for (i in 1:nrow(data_mps)) {

# - Initialize success flag and attempts counter

    success <- FALSE
    attempts <- 0

# - Try up to the number of trials specified

    while (!success && attempts < number_of_trials) {

      # - The system role is a description of the role the model should
      # - assume when generating the response. 
      
      system_role <- "You are a political analyst who needs to analyze the characteristics of a politician's policies. You have been asked to provide a JSON output for the characteristics of a politician's policies."
      
      # - It is recommended to provide an example of the expected output to the 
      # - model. The example should come in two parts. One where the user 
      # - provide the input and one where you act like the model and provide the
      # - expected output. It is also possible to provide more than one example.
      # - In this case, you should add an additional list to the messages list 
      # - containing the example.
      
      user_command <- "Provide a list of 10 key characteristics describing Quebec MNA or Canada MP John Doe's policies formatted in JSON. Make sure to output 10 characteristics. Please answer to the best of your knowledge.Take a deep breath and work on this problem step by step."
      
      # - Here is an example of the expected output. It is important to provide 
      # - the expected output in the same format as the model output. In this 
      # - case, the expected output is a JSON string. It's important to define 
      # - the prompt_subject appropriately to match the expected output. This 
      # - will be used to extract the relevant content from the JSON response.
      
      system_example <- paste0("{'Name': 'John Doe', '", prompt_subject, "': ['Pro-environment', 'Supports renewable energy', 'Advocates for education reform', 'Pro-healthcare reform', 'Anti-corruption', 'Economic growth focus', 'Supports tax reform', 'Pro-immigration reform', 'National security emphasis', 'Supports digital privacy']}")
      
      # - This is the actual prompt, the one that the model will use to generate
      # - the response. It is important to provide clear and concise 
      # - instructions to the model.
      
      prompt <- paste0("Based on the previous example, Provide a list of 10 key characteristics describing ", paste0(data_mps$position[i]), " ", paste0(data_mps$name[i]), "'s policies formatted in JSON. Make sure to output 10 characteristics. Please answer to the best of your knowledge.Take a deep breath and work on this problem step by step.")
      
      # - Create a list of messages to send to the model. The messages should
      # - include the system role, user command, system example, and prompt.
      # - This list will be used as input to the model to generate the response.

      prompt_message <- list(list("role" = "system", "content" = system_role),
                             list("role" = "user", "content" = user_command),
                             list("role" = "system", "content" = system_example),    
                             list("role" = "user", "content" = prompt))

      # - Use the openai package to prompt the model with the messages and store
      # - the output in a chat_prompt object.

      chat_prompt <- openai::create_chat_completion(
        model = model_name,
        messages = prompt_message
      )

      cat(paste("Row", i, "of", nrow(data_mps), ", model used:", model_name, ",attempt", attempts + 1, "of", number_of_trials), "\n")

      # Storing the output of the model in an output object

      output <- chat_prompt$choices$message.content
      
# - Attempt to fix and parse the JSON. It deletes all the text before and after
# - the JSON content, and then attempts to parse the JSON. 

# -------------------- JSON Cleaning -------------------------------------------

      # Find the position of the first occurrence of "{"

      json_start <- regexpr("\\{", output)
      
      # Find all occurrences of "}" and select the last one

      all_json_ends <- gregexpr("\\}", output)
      last_json_end <- if (length(all_json_ends[[1]]) > 0) max(all_json_ends[[1]]) else -1
      
      # Check if we have valid start and end positions for the JSON content

      if (json_start > 0 && last_json_end > 0) {

          # Extract the JSON part from the output using the start and end positions

          json_content <- substr(output, json_start, last_json_end)
      } else {
          json_content <- ""  # Default to an empty string if positions are not valid
      }
      
# -------------------- JSON Parsing --------------------------------------------

      # Check if json_content is not empty before parsing

      if (nzchar(json_content)) {
          parsed_output <- tryCatch({
              jsonlite::fromJSON(json_content)
          }, error = function(e) {
              message("JSON parsing error: ", e$message)
              NULL
          })
      } else {
          message("No JSON content found.")
          parsed_output <- NULL
      }
      
# - If the JSON parsing is successful, it assigns the subject_content to the
# - corresponding columns for the current row. If the JSON does not contain any
# - subject_content, it prints a message and assigns NA to the corresponding
# - columns. If the JSON parsing fails, it prints a message and increments the
# - attempts counter. If all attempts fail, it prints a message and assigns NA
# - to the corresponding columns.

      if (!is.null(parsed_output) && prompt_subject %in% names(parsed_output)) {
        subject_content <- parsed_output[[prompt_subject]]
        num_subject_content <- length(subject_content)

        if (num_subject_content > 0) {
          subject_content_full <- c(subject_content, rep(NA, max(0, column_needed - num_subject_content)))
          data_mps[i, prompt_cols] <- subject_content_full[1:column_needed]
          success <- TRUE
        
        } else {
          message(paste("Parsed JSON does not contain any", prompt_subject, "for row:"), i)
        }

      } else {
        message(paste("Invalid or missing", prompt_subject, "field for row:", i, "on attempt", attempts + 1, "using model", model_name))
        attempts <- attempts + 1
        
        if (attempts < number_of_trials) {
          Sys.sleep(1)  # Short delay before retrying
        }
      }
    }

# - If all attempts fail, it assigns NA to the corresponding columns and prints 
# - a message. It then delays for 1 second to avoid hitting rate limits.

    if (!success) {
      data_mps[i, prompt_cols] <- NA
      message("All attempts failed for i: ", i, " using ", model_name)
    }

    # Delay to avoid hitting rate limits

    Sys.sleep(1)
    print(subject_content)

# - Save the updated dataframe every save_interval iterations. The data is saved
# - in RDS format with a filename that includes the model name and the current
# - iteration number.

    if (i %% save_interval == 0) {
      saveRDS(data_mps, paste0("data/backups/data_prompting_the_machine_checkpoint_", i, ".rds"))
      cat("Data saved at iteration", i, "\n")
    }
  }
}

# - Save the updated dataframe

saveRDS(data_mps, "data/data_prompting_the_machine.rds")